You can get “running apps” from KWin on Wayland via KDE’s Plasma Window Management protocol (org_kde_plasma_window_management). In practice, you’ll use KWayland Client classes to subscribe to window events, mirror them into a QAbstractListModel, and expose that model to your Qt Quick taskbar. Below is a minimal, end-to-end example.
Dependencies

    KDE Frameworks (KWayland Client; version depends on your stack, KF5 or KF6)

    Qt (Qt Quick + Core)

    Wayland session under Plasma (for app mode)

CMake (KF6 example):

cmake_minimum_required(VERSION 3.20)
project(CanvasDeskTaskbar LANGUAGES CXX)

find_package(Qt6 REQUIRED COMPONENTS Core Gui Qml Quick)
find_package(KF6Wayland REQUIRED) # or KF5WaylandClient if you're on KF5

add_executable(taskbar main.cpp PlasmaWindowModel.cpp)
target_link_libraries(taskbar
  Qt6::Core
  Qt6::Gui
  Qt6::Qml
  Qt6::Quick
  KF6::WaylandClient # KF5::WaylandClient for KF5
)

--
Minimal plasma window model (C++)

This model connects to the Plasma Window Management protocol, tracks windows, and exposes roles to QML. It also provides simple actions (activate, minimize, close).
cpp

// PlasmaWindowModel.h
#pragma once
#include <QAbstractListModel>
#include <QVector>
#include <memory>

namespace KWayland { namespace Client {
class ConnectionThread;
class Registry;
class PlasmaWindowManagement;
class PlasmaWindow;
}}

class PlasmaWindowModel : public QAbstractListModel {
    Q_OBJECT
public:
    enum Roles {
        TitleRole = Qt::UserRole + 1,
        AppIdRole,
        ActiveRole,
        MinimizedRole,
        MaximizedRole
    };
    Q_ENUM(Roles)

    explicit PlasmaWindowModel(QObject* parent = nullptr);
    ~PlasmaWindowModel() override;

    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    QHash<int, QByteArray> roleNames() const override;

    Q_INVOKABLE void requestActivate(int row);
    Q_INVOKABLE void requestClose(int row);
    Q_INVOKABLE void toggleMinimize(int row);
    Q_INVOKABLE void toggleMaximize(int row);

private:
    void initWayland();
    void addWindow(KWayland::Client::PlasmaWindow* w);
    void removeWindow(KWayland::Client::PlasmaWindow* w);

    struct Item {
        KWayland::Client::PlasmaWindow* w = nullptr;
        QString title;
        QString appId;
        bool active = false;
        bool minimized = false;
        bool maximized = false;
    };

    std::unique_ptr<KWayland::Client::ConnectionThread> m_conn;
    std::unique_ptr<KWayland::Client::Registry> m_registry;
    KWayland::Client::PlasmaWindowManagement* m_pwm = nullptr;
    QVector<Item> m_items;
};

// PlasmaWindowModel.cpp
#include "PlasmaWindowModel.h"
#include <QDebug>
#include <QGuiApplication>

#include <KWayland/Client/connection_thread.h>
#include <KWayland/Client/registry.h>
#include <KWayland/Client/plasmawindowmanagement.h>
#include <KWayland/Client/plasmawindow.h>

using namespace KWayland::Client;

PlasmaWindowModel::PlasmaWindowModel(QObject* parent)
    : QAbstractListModel(parent) {
    initWayland();
}

PlasmaWindowModel::~PlasmaWindowModel() {
    // Orderly teardown (optional; smart pointers handle most)
}

QHash<int, QByteArray> PlasmaWindowModel::roleNames() const {
    return {
        { TitleRole, "title" },
        { AppIdRole, "appId" },
        { ActiveRole, "active" },
        { MinimizedRole, "minimized" },
        { MaximizedRole, "maximized" }
    };
}

int PlasmaWindowModel::rowCount(const QModelIndex& parent) const {
    if (parent.isValid()) return 0;
    return m_items.size();
}

QVariant PlasmaWindowModel::data(const QModelIndex& index, int role) const {
    if (!index.isValid() || index.row() < 0 || index.row() >= m_items.size()) return {};
    const auto& it = m_items[index.row()];
    switch (role) {
        case TitleRole:     return it.title;
        case AppIdRole:     return it.appId;
        case ActiveRole:    return it.active;
        case MinimizedRole: return it.minimized;
        case MaximizedRole: return it.maximized;
        default: return {};
    }
}

void PlasmaWindowModel::initWayland() {
    m_conn = std::make_unique<ConnectionThread>();
    // Use default socket name; Plasma sets WAYLAND_DISPLAY
    QObject::connect(m_conn.get(), &ConnectionThread::connected, [this]() {
        m_registry = std::make_unique<Registry>();
        m_registry->create(m_conn.get());
        QObject::connect(m_registry.get(), &Registry::plasmaWindowManagementAnnounced,
                         this, [this](quint32 name, quint32 version) {
            m_pwm = m_registry->createPlasmaWindowManagement(name, version, this);
            QObject::connect(m_pwm, &PlasmaWindowManagement::windowCreated,
                             this, [this](PlasmaWindow* w) { addWindow(w); });
        });
        m_registry->setup();
    });
    m_conn->initConnection();
}

void PlasmaWindowModel::addWindow(PlasmaWindow* w) {
    Item item;
    item.w = w;
    item.title = w->title();
    item.appId = w->appId();
    item.active = w->isActive();
    item.minimized = w->isMinimized();
    item.maximized = w->isMaximized();

    const int row = m_items.size();
    beginInsertRows(QModelIndex(), row, row);
    m_items.push_back(item);
    endInsertRows();

    QObject::connect(w, &PlasmaWindow::titleChanged, this, [this, w]() {
        for (int i = 0; i < m_items.size(); ++i) if (m_items[i].w == w) {
            m_items[i].title = w->title();
            emit dataChanged(index(i), index(i), { TitleRole });
            break;
        }
    });
    QObject::connect(w, &PlasmaWindow::activeChanged, this, [this, w]() {
        for (int i = 0; i < m_items.size(); ++i) if (m_items[i].w == w) {
            m_items[i].active = w->isActive();
            emit dataChanged(index(i), index(i), { ActiveRole });
            break;
        }
    });
    QObject::connect(w, &PlasmaWindow::minimizedChanged, this, [this, w]() {
        for (int i = 0; i < m_items.size(); ++i) if (m_items[i].w == w) {
            m_items[i].minimized = w->isMinimized();
            emit dataChanged(index(i), index(i), { MinimizedRole });
            break;
        }
    });
    QObject::connect(w, &PlasmaWindow::maximizedChanged, this, [this, w]() {
        for (int i = 0; i < m_items.size(); ++i) if (m_items[i].w == w) {
            m_items[i].maximized = w->isMaximized();
            emit dataChanged(index(i), index(i), { MaximizedRole });
            break;
        }
    });
    QObject::connect(w, &PlasmaWindow::unmapped, this, [this, w]() {
        removeWindow(w);
    });
}

void PlasmaWindowModel::removeWindow(PlasmaWindow* w) {
    for (int i = 0; i < m_items.size(); ++i) if (m_items[i].w == w) {
        beginRemoveRows(QModelIndex(), i, i);
        m_items.remove(i);
        endRemoveRows();
        break;
    }
}

void PlasmaWindowModel::requestActivate(int row) {
    if (row < 0 || row >= m_items.size()) return;
    m_items[row].w->requestActivate();
}

void PlasmaWindowModel::requestClose(int row) {
    if (row < 0 || row >= m_items.size()) return;
    m_items[row].w->requestClose();
}

void PlasmaWindowModel::toggleMinimize(int row) {
    if (row < 0 || row >= m_items.size()) return;
    const bool target = !m_items[row].minimized;
    m_items[row].w->setMinimized(target);
}

void PlasmaWindowModel::toggleMaximize(int row) {
    if (row < 0 || row >= m_items.size()) return;
    const bool target = !m_items[row].maximized;
    m_items[row].w->setMaximized(target);
}

--

Wiring into QML (taskbar)

Register the model type and use it in your taskbar view.

// main.cpp
#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QQmlContext>
#include "PlasmaWindowModel.h"

int main(int argc, char** argv) {
    QGuiApplication app(argc, argv);
    QQmlApplicationEngine engine;

    PlasmaWindowModel windows;
    engine.rootContext()->setContextProperty("windowModel", &windows);
    engine.load(QUrl(QStringLiteral("qrc:/Main.qml")));
    if (engine.rootObjects().isEmpty()) return 1;
    return app.exec();
}

QML--
// Main.qml
import QtQuick 2.15
import QtQuick.Controls 2.15

Rectangle {
    width: 800; height: 60; color: "#20232a"

    ListView {
        id: taskList
        anchors.fill: parent
        orientation: ListView.Horizontal
        spacing: 8
        model: windowModel

        delegate: Rectangle {
            height: parent.height
            width: Math.max(120, titleText.paintedWidth + 40)
            color: active ? "#3a3f5a" : (minimized ? "#2a2d40" : "#2a2d34")
            radius: 4

            Row {
                anchors.centerIn: parent
                spacing: 8
                Text { id: titleText; text: title; color: "white" }
                Button {
                    text: minimized ? "Restore" : "Minimize"
                    onClicked: windowModel.toggleMinimize(index)
                }
                Button {
                    text: "X"
                    onClicked: windowModel.requestClose(index)
                }
            }

            MouseArea {
                anchors.fill: parent
                onClicked: windowModel.requestActivate(index)
            }
        }
    }
}

App mode vs DE mode

    App mode (inside Plasma Wayland): Use the client protocol exactly as above. The compositor (KWin) publishes windows; your taskbar subscribes and updates.

    DE mode (your app as the login-managed session using KWin):

        Keep KWin as the compositor.

        Start your shell (Qt Quick desktop) after KWin and connect as a client via the same protocol for window enumeration/control.

        If you ever replace KWin, you must implement the server side of the Plasma Window Management protocol (or provide wlr-foreign-toplevel-management) so your taskbar still works.

Practical notes

    Ensure you run under Plasma Wayland; under X11 or other compositors, the KDE protocol won’t be available.

    Guard your model against missing protocol announcements to avoid crashes (e.g., show an empty taskbar if pwm is null).

    If you need panels/desktop components that position themselves, look into the PlasmaShell protocol (org_kde_plasma_shell) for shell surfaces and roles; regular xdg-shell windows cannot self-place.

If you share the specific behaviors you want for the task area (icons, previews, grouping, virtual desktops), I can extend the model with those roles and actions so it slots right into your JSON-driven component system.

--second message --

me>

Well I have a general taskbar component but I would like a more general icon driven task icons, I enabled parent/child docking from the components (I have a panel component to be the parent to other components, if I need for it to be) so the user can maybe have the task icons as just on the desk, or to put them docked in the panel as a kind of task bar, etc. basically the taskbar component is a 'we already made this you' and the task icons are the 'build or yourself '

Got it — you’re essentially separating two layers of functionality:

    Taskbar component → a ready‑made, opinionated panel with task icons already laid out.

    Task icon component → a more atomic building block that users can place anywhere (on the desktop, docked in a panel, grouped, etc.), giving them freedom to “build their own” taskbar or just scatter icons.

That’s a smart design because it keeps your editor modular and lets users choose between convenience and creativity.
How to Implement Icon‑Driven Task Components

Since you already have parent/child docking logic, the missing piece is exposing each running app as an individual component instance. Here’s how you can wire it:

    Model of running apps

        Use the Plasma Window Management protocol (KWin Wayland) or wlroots’ foreign‑toplevel protocol.

        Each window becomes an entry in a QAbstractListModel.

        Expose roles like title, appId, icon, active, minimized.

    Task icon component (QML)

        A small Rectangle or Image bound to one row of the model.

        Shows the app’s icon (from appId → lookup in icon theme).

        Click → requestActivate().

        Right‑click → context menu (close, minimize, maximize).

QML--
Item {
    property string appId
    property string title
    property bool active

    Image {
        source: "image://theme/" + appId
        anchors.centerIn: parent
        width: 32; height: 32
    }

    MouseArea {
        anchors.fill: parent
        onClicked: windowModel.requestActivate(index)
        onPressAndHold: windowModel.requestClose(index)
    }

    Rectangle {
        anchors.fill: parent
        color: active ? "#3a3f5a" : "transparent"
        radius: 4
    }
}


    Docking logic

        If the parent is a PanelComponent, icons line up horizontally/vertically.

        If the parent is the DesktopComponent, icons float freely with drag‑drop positioning.

        Same component, just different parent container.

    Taskbar convenience component

        Simply a Repeater or ListView of TaskIconComponent inside a styled panel.

        That’s your “we already made this for you” option.

⚖️ Benefits of This Split

    Flexibility: Users can build their own layouts (floating icons, docked bars, grouped panels).

    Consistency: Both taskbar and task icons use the same underlying model of running apps.

    Extensibility: You can later add features like grouping, previews, or drag‑to‑reorder without rewriting the core.

Next Step

Since you already have docking logic, the key is to expose the running apps model cleanly and then bind it to both the taskbar and task icon components. Once that’s in place, you’ll have a unified system where the taskbar is just a convenience wrapper around the same task icon building blocks.
